// WAVE EQUATION - Click and drag on the canvas.
// Hold down a key to animate with the JavaScript version.
// Compare this to the version generated by Emscripten: https://webassembly.studio/?f=kv3dhnahf1

import {
  getCanvasWidth: GetSizeType,
  getCanvasHeight: GetSizeType,
  log: LogType,
  Math_exp: F2F,
  Math_floor: F2I
} from 'env';

type LogType = (i32) => void;
type GetSizeType = () => i32;
type F2F = (f32) => f32;
type F2I = (f32) => i32;

export const memory: Memory<{initial: 1}>;
const INT_SIZE: i32 = 4;
const brushMatrixRadius: i32 = 28;
const brushWidth: i32 = 57;//brushMatrixRadius*2 + 1
const brushMatrix_size: i32 = 3249;//brushWidth^2

let HEAP_START: i32 = 0;
let IMAGE_START: i32 = 0;


function align(x: i32, by: i32): i32 {
	return x + by - x % by;
}

export function init(heapStart: i32): i32 {
  HEAP_START = heapStart;
  IMAGE_START = HEAP_START + align(brushMatrix_size * 4, 4);
  const brushMatrix: i32[] = HEAP_START;

  let p: i32 = 0;
  let q: i32 = 0;
  
  for (p = -brushMatrixRadius; p <= brushMatrixRadius; p+=1) {
    const row: i32 = p + brushMatrixRadius;

    for (q = -brushMatrixRadius; q <= brushMatrixRadius; q+=1) {
      const col: i32 = q + brushMatrixRadius;
      const element: i32 = Math_floor(0x3FFFFFFF *  Math_exp(-0.05 * ((p * p) + (q * q))));
      brushMatrix[row*brushWidth + col] = element;
    }
  }

  return IMAGE_START;
}

function applyCap(x: i32) : i32 {
  if (x < -0x40000000) {
    return -0x40000000;
  }
  if (x > 0x3FFFFFFF) {
    return 0x3FFFFFFF;
  }
  return x;
}

function toRGB(x: i32) : i32 {
  const val: i32 = x >> 22;
  if (val < 0) {
    return ((-(val + 1)) | 0xFF000000); //red
  }
  return (((val << 8) | (val << 16)) | 0xFF000000); // cyan
}

export function step(): void {
  const width: i32 = getCanvasWidth();
  const height: i32 = getCanvasHeight();
  const wh: i32 = width * height;

  const image: i32[] = IMAGE_START;
  const force: i32[] = IMAGE_START + wh * INT_SIZE;
  const status: i32[] = IMAGE_START + 2 * wh * INT_SIZE;
  const u: i32[] = IMAGE_START + 3 * wh * INT_SIZE;
  const vel: i32[] = IMAGE_START + 4 * wh * INT_SIZE;

  // Draw walls
  let i: i32 = 0;
  for (i = 0; i < height; i += 1) {
    status[i * width] = 1;
    status[i * width + width - 1] = 1;
  }
  for (i = 0; i < width; i += 1) {
    status[i] = 1;
    status[width * height - width + i] = 1;
  }

  // Calculate velocity change
  for (i = 0; i < wh; i += 1) {
    if (status[i] == 0) {
      const uCen: i32 = u[i];
      const uNorth: i32 = u[i - width];
      const uSouth: i32 = u[i + width];
      const uEast: i32 = u[i + 1];
      const uWest: i32 = u[i - 1];
      const uxx: i32 = (((uWest + uEast) >> 1) - uCen);
      const uyy: i32 = (((uNorth + uSouth) >> 1) - uCen);
      vel[i] = applyCap(vel[i] + (uxx >> 1) + (uyy >> 1));
    }
  }

  // Apply forces
  for (i = 0; i < wh; i += 1) {
    if (status[i] == 0) {
      const f: i32 = force[i];
      u[i] = applyCap(f + applyCap(u[i] + vel[i]));
      force[i] = f >> 1;
    }
  }

  // Generate image
  for (i = 0; i < wh; i += 1) {
    if (status[i] == 1) {
      image[i] = 0xFFFF0000;
    } else {
      const rgb: i32 = toRGB(u[i]);
      image[i] = rgb;
    }
  }
}

export function applyBrush(x: i32, y: i32) {
  const width: i32 = getCanvasWidth();
  const height: i32 = getCanvasHeight();
  const wh: i32 = width * height;
  const brushMatrix: i32[] = HEAP_START;
  const force: i32[] = IMAGE_START + wh * INT_SIZE;
  
  let p: i32 = 0;
  for (p = -brushMatrixRadius; p <= brushMatrixRadius; p+=1) {
    const targetY: i32 = y + p;
    const row: i32 = p + brushMatrixRadius;
    
    if (!(targetY <= 0 || targetY >= height - 1)) {
      let q: i32 = 0;
      for (q = -brushMatrixRadius; q <= brushMatrixRadius; q+=1) {
        const targetX: i32 = x + q;
        const col: i32 = q + brushMatrixRadius;

        if (!(targetX <= 0 || targetX >= width - 1)) {
          const brushValue: i32 = brushMatrix[row * brushWidth + col];
          const targetIndex: i32 = targetY * width + targetX;
          force[targetIndex] += brushValue;
          force[targetIndex] = applyCap(force[targetIndex]);
        }
      }
    }
  }
}